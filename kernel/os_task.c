#include <stdio.h>
#include <string.h>

#include <os_task.h>
#include <os_api.h>

#include <sg_tasks.h>
#include <sg_appmodes.h>
#include <sg_os_param.h>


#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(os_task, LOG_LEVEL_DBG);



OsTaskCtrlType _OsTaskDataBlk[TASK_ID_MAX];
OsTaskType _OsCurrentTask;



///////////////////////////////////////////////////////////////////////////////
//                       OS Internal Functions                               //
///////////////////////////////////////////////////////////////////////////////
void OsClearActivationsCounts(void) {
	int t;

	for (t = 0; t < TASK_ID_MAX; t++) {
		_OsTaskDataBlk[t].activations = 0;
	}
}



void OsSetupScheduler(AppModeType mode) {
	int t;

	if (mode >= OS_MODES_MAX) {
		LOG_ERR("Error: AppMode \"%d >= OS_MODES_MAX\". Task init failed!", mode);
		return;
	}

	/* check all tasks marked as autostart */
	for (t=0; t < TASK_ID_MAX; t++) {
		/* initialize ceiling priority same as configured priority */
		_OsTaskDataBlk[t].ceil_prio = _OsTaskCtrlBlk[t].priority;

                /* do sanity check - for any hand modification of sg code */
                if (t != _OsTaskCtrlBlk[t].id) {
                        LOG_ERR("Error: %s(), task.id (%d) != id (%d)! Try do \
                        a clean build.", __func__, _OsTaskCtrlBlk[t].id, t);
                        continue; // skip this
                }

                /* ready tasks if set for autostart */
                if (_OsTaskCtrlBlk[t].autostart) {
                        _OsTaskDataBlk[t].state = READY;
                }
		_OsTaskDataBlk[t].activations = 0;

                /* all set, we can now create a thread for this task */
                _OsTaskDataBlk[t].tid = k_thread_create(&_OsTaskDataBlk[t].thread, /* struct k_thread* */
                        _OsStackPtrList[t],                     /* k_thread_stack_t * stack */
                        _OsTaskCtrlBlk[t].stack_size,              /* stack_size */
                        _OsTaskEntryList[t],                    /* k_thread_entry_t entry*/
                        NULL, NULL, NULL,                       /* p1, p2, p3 */
                        K_PRIO_COOP(_OsTaskCtrlBlk[t].priority),   /* priority (smaller == higher in zephyr) */
                        0,                                      /* uint32_t options */
                        K_MSEC(1)                               /* TODO: no delay; OsTaskSchedConditionsOk() takes care of OSEK's */
                );
	}
	LOG_INF("Car-OS Scheduler setup done!");
}



/* The following function is defined in os_alarm.c */
int OsHandleCounters(void);

int OsScheduleTasks(void) {
	OsTaskType* task;
	u32 tick_cnt;
	static u32 tick_cnt_old;
	int t;

	/* Timer / Counter handling */
	tick_cnt = _GetOsTickCnt();
	if (tick_cnt != tick_cnt_old) {
		OsHandleCounters();
		tick_cnt_old = tick_cnt;
	}

	/* Scheduling of Tasks */
	for (t=0; t < TASK_ID_MAX; t++) {
		if (_OsTaskDataBlk[t].state == READY) {
			k_thread_resume(_OsTaskDataBlk[t].tid);
		}
	}
}



int OsSetCeilingPrio(u32 prio) {
	if (prio > OS_MAX_TASK_PRIORITY) {
		LOG_ERR("Error: %s() called with invalid priority %d", __func__, prio);
		return E_OS_ID;
	}

	DisableAllInterrupts();
	_OsTaskDataBlk[_OsCurrentTask.id].ceil_prio = prio;
	EnableAllInterrupts();
	return 0;
}



int OsClrCeilingPrio(void) {
	u32 prio;

	DisableAllInterrupts();
	prio = _OsTaskCtrlBlk[_OsCurrentTask.id].priority;
	_OsTaskDataBlk[_OsCurrentTask.id].ceil_prio = prio;
	EnableAllInterrupts();
	return 0;
}


///////////////////////////////////////////////////////////////////////////////
//                     Thread Control Functions                              //
///////////////////////////////////////////////////////////////////////////////


/// @brief This function will be called by thread entry point functions for each tasks
///        defined (auto-generated) by Os-builder in sg_tasks.c, before scheduling tasks
///        triggered by Zephyr RTOS's threads.
/// @param task_id - an integer number, auto generated by os_builder python script
/// @return TRUE if this task can be scheduled. FALSE if not to be scheduled.
bool OsTaskSchedConditionsOk(uint32_t task_id) {
        int m;
        bool retval = FALSE;
        bool appmode_ok = FALSE;
        AppModeType appmode;
        AppModeType *task_app_modes;

        /* input validation */
        if (task_id >= TASK_ID_MAX) {
                printf("ERROR: %s(): input validation failure!\n", __func__);
                return retval;
        }

        /* check if task is configured to run in this mode */
        appmode = GetActiveApplicationMode();
        task_app_modes = ((AppModeType*)_OsTaskCtrlBlk[task_id].appmodes);
	for (m=0; m < _OsTaskCtrlBlk[task_id].n_appmodes; m++) {
                if (appmode == task_app_modes[m]) {
                        appmode_ok = TRUE;
                        break;
                }
        }

        if ((_OsTaskDataBlk[task_id].state == READY) && (appmode_ok)) {
		_OsTaskDataBlk[task_id].activations++;
		_OsTaskDataBlk[task_id].state = RUNNING;
                retval = TRUE;
        }

        return retval;
}


/// @brief This function is called by zephyr's thread at the end of every scheduling
///        loop. It can schedule and reach here and it can reach here without 
///        scheduling of Task as well.
/// @param task_id
void OsTaskEndOfLoop(uint32_t task_id) {
	if (_OsTaskDataBlk[task_id].activations >= _OsTaskCtrlBlk[task_id].activations) {
		// this task has used its activation limits, suspend it
		_OsTaskDataBlk[task_id].state = WAITING;
		k_thread_suspend(_OsTaskDataBlk[task_id].tid);
	}
	else {
		// this task is ready to run again, but
		_OsTaskDataBlk[task_id].state = READY;
		// give other threads (Tasks) an opportunity to schedule
		k_sleep(K_TICKS(1));
	}
}


///////////////////////////////////////////////////////////////////////////////
//                          Public Functions                                 //
///////////////////////////////////////////////////////////////////////////////
/*/
Function: ActivateTask
Parameters:
  TaskID  Task reference.

Description: The task <TaskID> is transferred from the suspended state into the
             ready state. The operating system ensures that the task code is
	     being executed from the first statement.
/*/
StatusType ActivateTask(TaskType TaskID) {
	StatusType stat = E_OK;

	if (TaskID >= TASK_ID_MAX) {
		LOG_ERR("Error: %s() called with invalid TaskID %d", __func__, TaskID);
		return E_OS_ID;
	}

	_OsTaskDataBlk[TaskID].state = READY;

	return stat;
}




/*/
Function: TerminateTask
Parameters: None
Description: This service causes the termination of the calling task. The 
             calling task is transferred from the running state into the
	     suspended state.
/*/
StatusType TerminateTask(void) {
	/* mark the current task as not running */
	_OsTaskDataBlk[_OsCurrentTask.id].state = SUSPENDED;
	k_thread_abort(_OsTaskDataBlk[_OsCurrentTask.id].tid);	
	
	/* this call may not reach here, if trure the line below is to satisfy the compiler */
	return E_OK;
}



/*/
Function: ChainTask
Parameters: TaskID
Description: This service causes the termination of the calling task. After
   	     termination of the calling task a succeeding task <TaskID> is
	     activated. Using this service, it ensures that the succeeding task
	     starts to run at the earliest after the calling task has been
	     terminated.
/*/
StatusType ChainTask(TaskType TaskID) {
	if (TaskID >= TASK_ID_MAX) {
		LOG_ERR("Error: %s() called with invalid TaskID %d", __func__, TaskID);
		return E_OS_ID;
	}

	/* mark the current task as not running */
	_OsTaskDataBlk[_OsCurrentTask.id].state = SUSPENDED;

	/* move the task passed to resume state */
	ActivateTask(TaskID);
	
	return E_OK;
}



/*/
Function: Schedule 
Parameters: None
Description: If a higher-priority task is ready, the internal resource of the
             task is released, the current task is put into the ready state,
	     its context is saved and the higher-priority task is executed.
	     Otherwise the calling task is continued.
/*/
StatusType Schedule(void) {
	// TODO: Clean up Schedule OSEK function
	// u32 sp_ctx;
	// //LOG_ERR("sp_top: %X\n", _OsTaskDataBlk[_OsCurrentTask.id].sp_top);
	// /* save the context of this task, for resuming later */
	// sp_ctx = _save_context(_OsTaskDataBlk[_OsCurrentTask.id].sp_top);
	// /* return if this call is resuming from previous context save */
	// if (_OsTaskDataBlk[_OsCurrentTask.id].context_saved) {
	// 	_OsTaskDataBlk[_OsCurrentTask.id].context_saved = false;
	// 	return E_OK;
	// }
	// //LOG_ERR("sp_ctx: %X\n", sp_ctx);
	// _OsTaskDataBlk[_OsCurrentTask.id].sp_ctx = sp_ctx;
	// _OsTaskDataBlk[_OsCurrentTask.id].context_saved = true;

	// /* add this task to ready queue, as the scheduler would have removed it */
	// ActivateTask(_OsCurrentTask.id);

	// /* time to stop the current execution */
	// _set_sp_and_pc(_OsKernelSp, _OsKernelPc);
	
	/* control never reaches this line */
	return E_OK;
}



/*/
Function: GetTaskID
Parameters: pointer to TaskID
Description: GetTaskID returns the information about the TaskID of the task
	     which is currently running.
/*/
StatusType GetTaskID(TaskRefType pTaskID) {
	if (pTaskID == NULL) {
		LOG_ERR("Error: %s() taskID reference is NULL", __func__);
		return E_OS_ARG_FAIL;
	}
	*pTaskID = _OsCurrentTask.id;

	return E_OK;
}



/*/
Function: GetTaskState
Parameters: arg1: TaskID, arg2: pointer to State
Description: Returns the state of a task (running, ready, waiting, suspended)
	     at the time of calling GetTaskState.
/*/
StatusType GetTaskState(TaskType TaskID, TaskStateRefType pState) {
	if (TaskID >= TASK_ID_MAX) {
		LOG_ERR("Error: %s() called with invalid TaskID %d",
			__func__, TaskID);
		return E_OS_ID;
	}

	if (pState == NULL) {
		LOG_ERR("Error: %s() taskID reference is NULL", __func__);
		return E_OS_ARG_FAIL;
	}
	*pState = _OsTaskDataBlk[TaskID].state;

	return E_OK;
}
